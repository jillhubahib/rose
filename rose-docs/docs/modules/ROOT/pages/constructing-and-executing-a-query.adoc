= Constructing and Executing a Query

To select all columns from all rows in the `Customer` table:

[source,typescript]
----
include::example$/test/constructing-and-executing-a-query.ts[tag=example1,indent=0]
----

<1> We select all columns by passing `CustomerAllColumns`. This comes from code generated by `rose-cli`.
<2> A query is not executable until it is "finalised", which converts it to a SQL string. We pass an empty object,
representing the parameters that are accepted by the query. (This will be explained later.)
<3> Finally, we execute the query, passing it some "queryable" object such as an instance of `pg.Client` from the `pg`
library. We pass an object containing the query parameters; in this query, we have none, so the object is empty.

The value in `rows` will be an array of objects, each containing a property for every column; `firstName` for the column
`first_name`, `createdDate` for the column `create_date`, etc.

Now, let's only get the first and last names of every customer.

[source,typescript]
----
include::example$test/constructing-and-executing-a-query.ts[tag=example2,indent=0]
----

This time, we pass in an object with only two properties. The property names act as an "alias" of the underlying column.
The values are "column metamodels", generated from `rose-cli`. Think of it as a description of a column.

Notice that we never specify the table to query. This is because the column metamodel already knows which table it
belongs to. The query builder will try to infer any tables that are not explicitly listed in "from" or "join" clauses.

We could have also explicitly listed the "from" table:

[source,typescript]
----
include::example$test/constructing-and-executing-a-query.ts[tag=example3,indent=0]
----

The generated SQL will be the same.

Now, let's retrieve the first and last name of a single customer, by their customer ID.

[source,typescript]
----
include::example$test/constructing-and-executing-a-query.ts[tag=example4,indent=0]
----

<1> `withParams()` is a convenience function. We use it to specify what parameters the query will accept.

<2> We pass a callback function, which accepts a `ParamsProxy` and returns a query builder.

<3> We've added a `where()` clause, comparing the `customerId` to the query parameter `customerIdToFind`. (Note that
`customerIdToFind` does not yet have a value; we're actually inserting a placholder that will be resolved when the
query is executed.)

<4> When finalising the query, we pass in the `ParamsProxy` object. This tells the query builder what query parameters
will be accepted.

<5> Finally, when we execute the query, we must pass in an object with the property `customerIdToFind`.

[WARNING]
====
`withParams()` returns a function that should be invoked immediately! For example, `withParams()(callback)`. This is a hack to get TypeScript's type
inference working nicely.

If you are a TypeScript guru and can think of a way to avoid this, please get in contact!
====

[NOTE]
====
A `ParamsProxy` is an object that pretends to have the same properties as the type given to `withParams()`, but uses
magic; every property will actually return a placeholder that can be used in query building.
====
